"""
DOCME
"""
# Tim Miller
# 12/29/2010


import re
import os
import itertools
from charmming.const.etc import alphanum, alpha
from charmming.lib.mol import Mol
from charmming.lib.atom import Atom
from charmming.tools import Property, expandPath, cleanStrings, paragraphs,\
        lowerKeys


def get_formatting(input):
    """
    Takes a string representing the location of a .crd file or an
    iterator of strings as input, and returns a string indicating the
    formatting of the pdb data: "shortcard", "longcard" or "unknown".
    """
    try:
        iterator = ( line.lower() for line in open(input) if
                     not line.lower().startswith(('*')) and len(line) > 22 )
    except IOError:
        iterator = ( line.lower() for line in input
                     if not line.lower().startswith(('*')) and len(line) > 22 )

    short  = False
    long   = False
    badlen = False
    for line in iterator:
        if len(line) == 70:
            short = True
        elif len(line) == 140:
            long = True
        else:
            badlen = True

    if badlen:
        return 'unknown'
    if short and not long:
        return 'shortcard'
    if long and not short:
        return 'longcard'
    return 'unknown'


class CRDFile(object):
    """
    Class Attributes
        `_autoInFormat`
    Public Attributes
        `warnings`
    Properties
        `code`
        `crd`
        `filename`
        `footer`
        `header`
        `inFormat`
        `path`
    Public Methods
        `get_warnings`  TODO :: Sophisticated warning handling
        `iter_all`
        `iter_models`
        `keys`
    Private Methods
        _get_formatting
        _partitions
        _build_models
    Special Methods
    """

    _autoInFormat = 'shortcard'
    """
    A string that defines the default input formatting for all class
    instances.
    """

    def __init__(self, filename, **kwargs):
        """
        kwargs:
            `informat`      ['auto','shortcard','longcard']
            `autofix`       [False,True]    # Flag for atom._autoFix
            `verbose`       [False,True]
        """
        # kwargs
        kwargs = lowerKeys(kwargs)
        inFormat = kwargs.pop('informat', 'auto')
        self._autoFix = kwargs.pop('autoFix', False)
        self._verbose = kwargs.pop('verbose', False)
        #
        self.warnings = []
        # Filename
        self.filename = filename
        if self._verbose:
            print 'Parsing data from `%s`\n' % filename
        # Partitioning
        self._partitions()          # self.header / self.crd / self.footer
        # Input Formatting
        if inFormat == 'auto':
            self._inFormat = self._get_formatting(self.filename)
        else:
            self._inFormat = inFormat
        if self._verbose:
            print '%s: Input formatting set to `%s`' % (self.code, self.inFormat)
        # Processing -- this is simpler than the PDB case because we
        # do not have multiple models
        self._build_crd()

##############
# Properties #
##############

    @Property
    def crd():
        doc =\
        """
        The atomic coordinate data from the .crd file, in its
        unadulterated text form.
        """
        def fget(self):
            return self._crd
        return locals()

    @Property
    def filename():
        doc =\
        """
        The name of the .crd file from which this `CRDFile` instance
        was created.
        """
        def fget(self):
            return self._filename
        def fset(self, value):
            self._filename = expandPath(value)
        return locals()

    @Property
    def header():
        doc =\
        """
        The metadata in the .crd file that precedes the atomic
        coordinate data.  This property gives access to its
        unadulterated text form.
        """
        def fget(self):
            return self._header
        return locals()

    @Property
    def inFormat():
        doc =\
        """
        The formatting of the input data: "shortcard" or "longcard".
        """
        def fget(self):
            return self._inFormat
        return locals()

    @Property
    def path():
        doc =\
        """
        The path of the .crd file from which this `CRDFile` instance
        was created.
        """
        def fget(self):
            return os.path.dirname(self.filename)
        return locals()

##################
# Public Methods #
##################

    def get_warnings(self):
        """
        Return a list of warnings generated by the PDBFile object
        itself, and all of the Mol objects it contains.
        """
        result = self.warnings[:]
        for mol in self.iter_all():
            result.extend(mol.warnings)
        return result

    def iter_all(self):
        """
        Iterate over all of the PDBFile's Mol objects, regardless of
        their origin.
        """
        return itertools.chain(self.iter_models())

    def keys(self):
        """
        Lists the keys to access all of the Mol objects the PDBFile
        object contains.
        """
        models = [ 'model%d' % i for i in sorted(self._models.keys()) ]
        return models

###################
# Private Methods #
###################

    def _build_crd(self):
        """
        Parse the crd section, and load the coordinates into `Mol`
        objects, one `Mol` object per model section in the .pdb file.
        """

        if self.inFormat == 'shortcard':
            iterator = ( Atom(text=line, informat='shortcard', index=i,
                        autofix=self._autoFix) for i, line in enumerate(self.crd) if len(line) == 70 )
        elif self.inFormat == 'longcard':
            iterator = ( Atom(text=line, informat='longcard', index=i,
                        autofix=self._autoFix) for i, line in enumerate(self.crd) if len(line) == 140 )

        self._models[modelNum] = Mol(iterable=iterator, name='crdmol',
                                     autofix=False)

    def _get_formatting(self, filename):
        """
        Wrapper method to detect PDB text formatting, defaults to 'pdborg'
        """
        result = get_formatting(filename)
        if result == 'unknown':
#WARN       # Throw a warning if formatting is guessed.
            self.warnings.append('Undetected crd formatting')
            return self.__class__._autoInFormat
        else:
            return result

    def _partitions(self):
        """
        Partition the file into _header/_crd/_footer sections.
        """
        filePointer = open(self.filename)
        # Populate header
        self._header = []
        self._crd = []
        tmp = None
        for line in cleanStrings(filePointer):
            if line.startswith(('*')) or len(line) < 30:
                self._header.append(line)
            else:
                self._crd.append(line)

        self._footer = []
        filePointer.close()

###################
# Special Methods #
###################

    def __getitem__(self, key):
        if key in self.keys():
            try:
                if key.startswith('model'):
                    return self._models[int(key.split('model')[1])]
                else:
                    raise IndexError
            except IndexError:
                raise KeyError('Unknown Key: %s' % key)
        else:
            try:
                dummy = int(key)
                try:
                    return self._models[key]
                except IndexError:
                    raise KeyError('Unknown Key: %s' % key)
            except ValueError:
                raise KeyError('Unknown Key: %s' % key)

    def __len__(self):
        return len(self._models)

    def __contains__(self, key):
        return key in self.keys()

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.keys())
